import java.util.Arrays;
import java.util.Random;

public class Board {
	int height;
	int width;
	boolean[][] squares; //an array of arrays
	
	public Board() { //the constructor
		this.height=5; //this board's height
		this.width=5; //this board's width
		this.squares=new boolean[width][height]; //this board's squares
	}
	
	public Board(Board oldBoard) { //constructor that takes pre-existing board and copies it
		this.height=oldBoard.height; //make the new board height the same as the old board
		this.width=oldBoard.width; //make the new board width the same as the old board
		this.squares=new boolean[this.width][this.height];
		
		for(int i = 0; i < oldBoard.squares.length; i++) {
			this.squares[i] = oldBoard.squares[i].clone(); //this clones the board because otherwise it would have just been a pointer to the old board and would have messed with the old board rather than the new one
		}
	}
	
	public Board(boolean random) { //constructor that creates the randomized board
		if (random) {
			this.height=5; //this board's height
			this.width=5; //this board's width
			this.squares=new boolean[this.width][this.height];
			 Random randomno = new Random(); //variable to create randomized board
			for (int yCount=0; yCount < height; yCount++) 
			{
				for (int xCount = 0; xCount < width; xCount++)
				{
					this.squares[xCount][yCount]= randomno.nextBoolean(); //gets the randomized boolean value 
				}
			}
			
		}
		
		else {
			this.height=5; //this board's height
			this.width=5; //this board's width
			this.squares=new boolean[width][height];
		}
	}
	
	public Board flip(int x, int y) { //call flip on an existing board
		Board newBoard = new Board(this);
		
			for(int yCount=0; yCount < height; yCount++) { //flips the y axis only
				newBoard.squares[x][yCount] = !newBoard.squares[x][yCount]; //flip this only when it's not equal to the new orientation
			}
			
			for(int xCount = 0; xCount < width; xCount++) { //flips the x axis only
				newBoard.squares[xCount][y] = !newBoard.squares[xCount][y]; //flip this only when it's not equal to the new orientation
			}
			
			newBoard.squares[x][y]=!newBoard.squares[x][y]; //flips it a third time because one of them is flipped twice
			
			return newBoard; //display the new board 
		
	}
	
	public String toString() { //turns object into a string because I don't want the storage location displayed
		String st="";
		
		for (int yCount=0; yCount < height; yCount++) 
		{
			for (int xCount = 0; xCount < width; xCount++)
			{
				st=st+" ";
			if(squares[xCount][yCount]) { //helps with things being uneven -- changes the letters to black and white instead of true and false
				st=st+"w"; //true
			}
			else
			{
				st=st+"b"; //false
			}
			}
			st=st+"\n"; //line break
		}
		
		return st;
	}

	@Override //get prime number and factor in the part of the object to generate the hashcode. Generated by the Eclipse IDE
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + height;
		result = prime * result + Arrays.deepHashCode(squares);
		result = prime * result + width;
		return result;
	}

	@Override //system generated to help compare objects, created by the Eclipse IDE
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Board other = (Board) obj;
		if (height != other.height)
			return false;
		if (!Arrays.deepEquals(squares, other.squares))
			return false;
		if (width != other.width)
			return false;
		return true;
	}
}
